def hangman(word):
    wrong = 0  #誤り回数の変数を定義
    stages = ["",
              "______     ", #誤ったら左記を一行ずつ表示する
              "|          ",
              "|     |    ",
              "|     0    ",
              "|    /|/   ",
              "|    /|    ",
              "|          ",
              ]
    rletters = list(word)  #正解wordの文字列を、一文字ずつにしてリストに格納。正解毎に、文字列が$に変わる。
    board = ["_"] * len(word)  #正解wordの文字列分、"_"を表示するリスト。あたったら文字列置換
    win = False #初期値はFalse判定にして置き、勝利数の記録を残す
    print("ハングマンへようこそ！")

#ゲームの処理フロー（勝敗が付くまで繰り返す処理）
    
    while wrong < len(stages) -1 :  #stagesの文字数をカウントし、hangmanが完成するまで繰り返す
        print("\n")
        msg = "1文字を予想してね" #この位置で変数定義をする必要性がわからない。そもそも、変数定義する必要あるのか。このプログラム上はふようかもしれない。ただ、共通で使用するであろうメッセージはマジックワード/ナンバーにならないように変数定義して意味を明確にしているのかも
        char = input(msg)  #プレイヤーが入力した情報を変数に格納
        if char in rletters: #単語の構成要素文字listに含まれていた場合の処理
            cind = rletters.index(char) #indexメソッドにより、入力された文字列がリストの何番目なのか示し、変数cindに格納
            board[cind] = char #"_"で文字数分表示していた文字列の該当箇所を、正解した文字列で再定義する
            rletters[cind] = '$' #もし、wordで正解文字列を持たない場合、２つ以上同じ文字列があると、処理順序上、最初の文字列しか、参照されなくなってしまう。そのため、正解した文字列を探索するリストから省く必要があった。
        else:
            wrong += 1 #間違えた場合、カウントアップ。後工程で使用。
        print(" ".join(board)) #成否にかかわらず、現時点で判明している文字列を表示。
        e = wrong + 1 #誤りカウントに+1しておき、スライス（文字列の開始位置・終了位置の明示）可能にする
        print("\n".join(stages[0:e]))  #誤り回数に則したhangmanを表示
        if "_" not in board: #表示後、もし、そこに不明な文字列が含まれていなかった場合、プレイヤーの勝ちを宣告
            print("あなたの勝ち！")
            print(" ".join(board))
            win = True
            break
    if not win:
        print("\n".join(stages[0:wrong+1])) #hangman（完全体）を表示1
        print("あなたの負け！正解は・・・{}！".format(word)) #wordのフォーマットを整えて、正解発表！

    #あとは、プログラム上で、hangman関数に引数word（問題となるワード）を与えればよい
